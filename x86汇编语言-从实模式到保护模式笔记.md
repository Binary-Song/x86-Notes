# x86汇编语言：从实模式到保护模式 笔记



## 第二章 处理器、内存和指令

### 2.2 寄存器和算术逻辑部件

8086具有16位寄存器，可以容纳16比特。

1 byte = 8 bit

1 word = 2 byte = 16 bit

1 double word = 2 word = 32 bit

算术逻辑部件（ALU）读取寄存器的数字，计算后将结果写入寄存器。

### 2.3 内存储器

内存单次能按字节、字、双字和四字进行访问。

### 2.4 指令和指令集

8086指令的长度可变。

对于内存中的一个字，Intel处理器采用小端序（Little Endian）。即数的低位放在小地址处，高位放在大地址处。例如，如果从地址0000开始存放数005D，则0000处为5D，0001处为00。

### 2.5 古老的Intel 8086处理器

8086有8个通用寄存器：

- **AX** （Accumulator）累加器

- **BX** （Base Register）基址寄存器

- **CX** （Count Register）计数寄存器

- **DX** （Data Register）数据寄存器

- **SI** （Source Index）源变址寄存器

- **DI** （Destination Index）目标变址寄存器

- **BP** （Base Pointer）基址指针寄存器

- **SP**（Stack Pointer）栈顶指针寄存器

其中AX、BX、CX、DX可以分为AH、AL、BH、BL、CH、CL、DH、DL。用来将16位寄存器拆成2个8位寄存器访问。

物理地址 =（段地址 << 4） + 逻辑地址

8086有4个段寄存器

- **CS** （Code Segment）代码段寄存器
- **DS**（Data Segment）数据段寄存器
- **ES**（Extra Segment）附加段寄存器
- **SS**（Stack Segment）栈段寄存器

2 个控制寄存器

- **FLAGS** 标志寄存器
- **IP** 指令指针

## 第三章 汇编语言和汇编软件

### 3.1 汇编语言简介

`mov ax, 0x3f`相当于`ax = 0x3f`

`add bx ax`相当于`bx = ax + bx`

### 3.2 NASM 编译器

编译文件`nasm -f bin exam.asm -o exam.bin`

## 第四章 虚拟机的安装和使用

各个操作系统可能对程序有要求，不满足要求不能识别。所以要绕过该限制，就要在虚拟机上运行，把程序安装到MBR即可。

BIOS（基本输入输出系统）是固化在只读存储器（ROM）中的，它是开机执行的指令，占据内存顶端的64KB，范围0xF0000-0xFFFFF；DRAM则占据低端的640KB，范围0x00000-0x9FFFF。中间的部分0xA0000-0xE9999分给了其他外围设备。

指令从0xFFFF0处执行，一般这里是一个跳转。

如果设置为从硬盘启动，ROM-BIOS将读取MBR的内容，将它加载到0x0000: **0x7c00**。然后跳到那里执行。

## 第五章 编写主引导扇区代码

MBR的最后两个字节必须是0xaa、0x55

### 5.3 在屏幕上显示文字

显卡有文字模式，还有图形模式。

0xB8000-0xBFFFF是留给显卡的。

文本模式下显示的初始地址是 **0xB8000**。

**不允许用`mov`将一个立即数传送到段寄存器，必须通过中转。**

字符由2个字节表示，低位为ASCII码，高位为显示属性。显示属性前4位是前景色，后四4位是背景色。如下图：

低位 → 高位

K R<sub>f</sub> G<sub>f</sub> B<sub>f</sub> I R<sub>b</sub> G<sub>b</sub> B<sub>b</sub>

K是闪烁位，I是高亮位。

其余表示前景色或背景色。

方括号`[]`表示对地址解引用。

### 5.4 显示标号的汇编地址

指令前面可以由标号，表示此处的汇编地址（程序开头为0）。

### 5.5 

`jmp near *标号* `

和

`jmp 地址`

不同！`jmp near` 的机器码的参数是向前/向后跳几个地址。编译器计算操作数的位置和调用`jmp`行的差得出此操作数

## 第六章

### 6.5 段之间的批量数据传送

ZF 是FLAGS的第六位，称为零标志。如果计算结果为0，置为1，否则为0。这包括未存储的计算结果，比如比较。

DF是FLAGS的第10位，称为方向标志。如果设为0，则表示从低地址到高地址处理。

`cld`将DF置0

`std`将DF置1

`movsb`和`movsw`指令将DS:SI 传送到ES:DI 。每次移动后，都会给SI和DI加一，方便你用`rep`执行这个指令

`rep`重复的次数由CX指定。

### 6.6 

`loop`的底层和`jmp near`一样，机器码参数也是向前向后跳多少。

### 7.7.3 内存寻址

1.直接寻址

用直接数寻址的方式

```asm
mov ax, [0x5c0f] ;段寄存器默认是ds
add word [0x0230], 0x5000 
xor byte [es:label_b], 0x05 ;指定段寄存器为es
```

2.基址寻址

用寄存器**`bx`**或**`bp`**寻址的方式

```
mov [bx], dx
```

**当使用BX时，默认段寄存器为DS；当使用BP时，默认段寄存器为SS！**

# 重点注意

MBR头：0x7c00

显存头：0xB8000

**不能从内存`mov`到内存，用寄存器中转！**

**主引导扇区大小为512字节，减去标志位0x55 0xaa还剩510字节，所以程序末尾往往是：**

```assembly
    times 510-($-$$)     db 0
                         db 0x55,0xaa
```

little endian = **Least significant byte first**

按小端字节序如0x12345678存放在一个双字内是：

```
Addr 00 01 02 03
Mem  78 56 34 12
```

big endian =  **Most significant byte first**

 

### 8.3.4

端口就是IO接口上的寄存器。

连接硬盘的PATA/SATA接口有好几个端口：

命令端口：写入0x20表示读取，0x30表示写入

状态端口：根据它判断硬盘工作是否正常

参数端口：告诉硬盘读写的扇区数量和逻辑扇区号码

数据端口：通过它取得或写入数据

端口的数据宽度是不确定的，PATA/SATA端口是16位的。

端口分为内存映射（Memory-mapped I/O, MMIO）和独立编址（isolated I/O, Port-mapped I/O, PMIO）的。

IOH（I/O Controller Hub）芯片，又称南桥。

in指令：从端口读取

```
in A, B 
```

A代表目的寄存器，**必须是AL（8位端口）或AX（16位端口）**。读取的内容将会放在此中。

B可以是DX或者8位立即数（0x00 ~ 0xff），代表端口号。如果想要访问255以上的端口号，只能用DX。

out指令：向端口写入

```
out A, B
```

A是端口号，B是数据。B必须是AL或AX，A可以是DX或者8位立即数。如果想要访问255以上的端口号，只能用DX。

```assembly
out 0x37,al     ;写 0x37 号端口（这是一个 8 位端口）
out 0xf5,ax     ;写 0xf5 号端口（这是一个 16 位端口）
out dx,al       ;这是一个 8 位端口，端口号在寄存器 DX 中
out dx,ax       ;这是一个 16 位端口，端口号在寄存器 DX 中
```

### 8.3.5 

硬盘读写的基本（最小）单元是扇区。**1扇区 = 512 Bytes**。

读写数据的模式：

CHS模式：向硬盘控制器发送磁头号、柱面号和扇区号。

LBA模式：只使用逻辑扇区。

LBA28：使用28个比特来表示逻辑扇区号。最大可以表示 2^28扇区 = 2 ^ 28 * 2 ^ 9 B = 2 ^ 37 B = 128 GB

LBA48：使用48个比特来表示逻辑扇区号。

硬盘控制器端口：0x1f0-0x1f7 共8个

读扇区过程

```assembly
; 1. 设置要读取的扇区数量
mov dx, 0x1f2
mov al, 0x01   
out dx, al   ;将0x01写入0x1f2端口。该端口表示要读取的扇区数量，每读取一个扇区，其值就减一。如错误，则此为余下未读的扇区数。

```

如果给0x1f2端口写入0，则表示读256个扇区。

```asm
; 2. 设置起始LBA扇区号
; 需要将扇区号分成4段，写入01f3 0x1f4 0x1f5 0x1f6中(LE)
mov dx, 0x1f3
mov al, 0x02
out dx, al   ;0x1f3 <- 0x02
inc dx    ;dx == 0x1f4
mov al, 0x00 
out dx, al ;0x1f4 <- 0x00
inc dx    ;dx == 0x1f5
out dx, al ; 0x1f5 <- 0x00
inc dx    ;dx == 0x1f6
mov al, 0xe0
out dx, al ;0x1f6 <- 0xe0
```

LBA扇区号存放在01f3 0x1f4 0x1f5 和 0x1f6的前4位中。

0x1f6的后4位中，首位表示硬盘号（0主盘，1从盘），末3位是"111"，表示LBA模式。

```assembly
; 3. 向端口0x1f7写入0x20，表示请求硬盘开始读。
mov dx, 0x1f7
mov al, 0x20
out dx, al

; 4. 等待操作完成
mov dx, 0x1f7
.waits:
	in al, dx ; al现在包含0x1f7状态端口的值
	and al, 0x88 ; 保留al中7，3两位，其余位清零。第7位若为1，则表示硬盘忙；第3为若为1，则表示硬盘准备号和主机交换数据。（另：第0位为1表示有错误，原因在0x1f1端口）
	cmp al, 0x08 
	jnz .waits ; 如果 al != 0000 1000 说明第七位或第三位不是我们想要的状态，要继续等待。

; 5. 连续取出数据
mov cx, 256
mov dx, 0x1f0 ; 从16位端口0x1f0中连续读数据
.readw:
	in ax, dx
	mov [bx], ax ; 假设bx里存放我们放数据的内存地址
	add bx, 2
	loop .readw
```

 ### 8.3.6

接下来分析加载器代码。它用来把硬盘中的程序加载到内存中。

16字节对齐 = 每16字节才能有一个段 = 段的首地址一定以0结尾。

定义mbr段：

```
SCETION mbr align=16 vstart=0x7c00
```

8086的四种调用方式

1. 16位相对近调用。近调用是指在同一个代码段内进行调用。相对是说操作数是16位的相对于本指令的偏移量。（编译器帮忙做减法）

   ```
   call proc_1
   ... 
   proc_1: ... 
   ```

2. 16位间接绝对近调用。操作数是真实地址。该地址由**寄存器或内存**给出。

   ```
   call cx
   call [0x3000]
   ```

3. 16位直接绝对远调用。远调用属于调用本段以外的程序。需要给出段地址。直接是说操作数是立即数。

4. 16位间接绝对远调用。

### 9.1

中断通过两个引脚输入处理器：NMI和INTR

NMI（Non-Maskable Interrupt）不能被屏蔽，属于严重的事件。NMI中断号为2，不细分，因为一般处理不了。

INTR可以屏蔽（无视）。

8259芯片负责处理中断，一个8259有8个引脚，IR0优先级最高，IR7最低。一个处理器有2个，接线方式见图9-2。它有自己的端口号，可以用in和out访问。主片0x20和0x21，从片0xa0，0xa1。

标志寄存器有个IF，当它为0时，将忽略所有中断；为1时，将接受和响应中断。

中断事件处理时也可能被更高优先级的打断，称为中断嵌套。

处理器在设计的时候就规定，当遇到修改SS的指令时，在这条指令和下一条指令之间禁止中断。因此SS和SP的修改要连着。

中断表是放在内存0x0000处的表。[中断号]=处理中断的代码的地址

### 10.3

32位模式

```
bits 32
```

32位有符号乘法

```
mul r/m32 ; edx:eax <- eax * r/m32
```

32位无符号乘法

```
imul r/m32 
```

### 11.2

32位保护模式也是使用段地址+偏移地址来访问内存。不过，段的访问有了限制。每个段都要登记，

每个记录就是一个描述符。每个段的描述符放在一起，称作全局描述符表（Global Descriptor Table, GDT）。**在进入保护模式前，必须定义全局描述符表。**

GDT的位置和大小存放在全局描述符表寄存器（GDTR）中，它是一个48位长度的寄存器，前32位是表在内存中的起始地址，后16位是表的长度减一，即最后一个字节的偏移量或下标。

描述符各位含义：


| 位    | 含义                                                         |
| ----- | ------------------------------------------------------------ |
| 0-15  | **段界限15-0**                                               |
| 16-31 | **段基地址15-0**                                             |
| 32-39 | **段基地址23-16**                                            |
| 40    | **A** = Accessed，当段被访问时，硬件将其置位。软件负责将其复位。 |
| 41    | **R/W**，R = Readable，如果复位，此段可执行但不可读取。W = Writable，如果复位，此段可读取但不可写。 |
| 42    | **C/E**                                                      |
| 43    | **Type** 如果置位，此为**代码段**描述符，D、C、R可用。如果复位，此为**数据**或**栈**段描述符 ，B、E、W可用。 |
| 44    | 1                                                            |
| 45-46 | **DPL**：DPL = Descriptor privilege level，想要访问此段的最低特权级别（ring）。 |
| 47    | **P**：P = Present，如果复位，任何对此段的引用都会产生一个"segment not present"错误。 |
| 48-51 | **段界限19-16**                                              |
| 52    | **AVL**：留给软件使用，硬件不使用。                          |
| 53    | **L**：L = Long，如果置位，D/B必须为0，此时表示该段是64位的。代码采用64位指令编码。 |
| 54    | **D/B**：D = Default operand size，如果复位，此为16位代码段，如果置位，此为32位代码段。B = Big，如果复位，此数据段的偏移最大为0xffff，否则为0xffffffff。总结：**复位适合16位代码段或数据段，置位适合32位。** |
| 55    | **G** = Granularity，如果复位，段界限的单位是1字节。如果置位，界限的单位是4096字节。 |
| 56-63 | **段基地址31-24**                                            |


A20地址线为了兼容8086设计。当禁用时，0xFFFFF加一的进位会回绕到0x00000。当启用时，会直接变成0x100000。
启用方法
```
         in al,0x92                          
         or al,0000_0010B
         out 0x92,al                        ;打开A20
```

 